#!/usr/bin/env ruby
# frozen_string_literal: true
require "optparse"
require "octokit"
require "fileutils"
require "yaml"
require "io/console"
require "base64"

require_relative "utils"

options = {}
opt =
  OptionParser.new do |opts|
    opts.banner = +<<~BANNER
    Usage: generate.rb [options] <manifest>
    BANNER
    [
      [
        "$GH_TOKEN, $GITHUB_TOKEN",
        "GitHub Personal Access Token to use for API requests"
      ]
    ].each do |env, description|
      opts.banner << "#{opts.summary_indent}#{env.ljust(opts.summary_width)} #{description}\n"
    end
    opts.on("-o", "--output [OUTPUT]", "Output file") do |o|
      options[:output] = o
    end
    opts.on("-r", "--run", "Whether to run Dockerfile") do |r|
      options[:run] = r
    end
    opts.on(
      "-i",
      "--include-manifest",
      "Whether to include the manifest in the Dockerfile"
    ) { |i| options[:include_manifest] = i }
    opts.on(
      "-y",
      "--yes",
      "Run Dockerfile without asking for confirmation"
    ) { |i| options[:yes] = i }
  end

opt.parse!

manifest_path = ARGV[0] or raise "No manifest file given"
output = options[:output] || "-"
run = options[:run] || false

client =
  Octokit::Client.new(access_token: ENV["GITHUB_TOKEN"] || ENV["GH_TOKEN"])

manifest = YAML.load_file(manifest_path)

dockerfile = [
  "# This Dockerfile was generated by vim-imagegen.",
  "# https://github.com/sevenc-nanashi/vim-imagegen"
]

if options[:include_manifest]
  dockerfile += [
    "# Original manifest:",
    indent(File.read(manifest_path).strip, "#   ")
  ]
end

dockerfile << ""
dockerfile << "FROM #{manifest["base_image"] || "ubuntu:22.04"}"

architecture = `docker info --format '{{.Architecture}}'`.strip

dockerfile << ""
dockerfile << "# Packages"
dockerfile << "RUN apt-get update && apt-get install -y curl git xz-utils bash rsync #{manifest["packages"]&.join(" ")}"

dockerfile << ""
dockerfile << "# Binaries"

manifest["external"]&.each do |binary|
  binary = { "name" => binary } if binary.is_a?(String)
  case binary["name"]
  when "deno"
    releases = fetch_tags("denoland/deno")
    releases =
      sort_by_version(releases.reject { |version| version.start_with?("std/") })
    version = resolve_version(releases, binary["version"], "deno")
    dockerfile << "# - Deno (#{version})"

    asset =
      client.release(
        "https://api.github.com/repos/denoland/deno/releases/tags/#{version}"
      )[
        "assets"
      ].find do |asset|
        asset["name"].end_with?(".zip") &&
          asset["name"].include?(
            architecture == "arm64" ? "aarch64" : "x86_64"
          ) && asset["name"].include?("linux")
      end

    raise "Asset not found" if asset.nil?

    dockerfile << "RUN apt-get install -y unzip"
    dockerfile << "RUN curl -Lfo /tmp/deno.zip #{asset["browser_download_url"]}"
    dockerfile << "RUN unzip /tmp/deno.zip -d /usr/local/bin"
  when "python", "ruby", "node"
    tags = fetch_tags("containerbase/#{binary["name"]}-prebuild")
    versions = sort_by_version(tags)
    version = resolve_version(versions, binary["version"], binary["name"])

    dockerfile << "# - #{binary["name"].capitalize} (#{version})"
    asset =
      client.release(
        "https://api.github.com/repos/containerbase/#{
          binary["name"]
        }-prebuild/releases/tags/#{version}"
      )[
        "assets"
      ].find do |asset|
        asset["name"].end_with?(".tar.xz") &&
          asset["name"].include?(architecture == "arm64" ? "aarch64" : "x86_64")
      end

    raise "Asset not found" if asset.nil?

    dockerfile << "RUN curl -Lfo /tmp/#{binary["name"]}.tar.xz #{asset["browser_download_url"]}"
    dockerfile << "RUN mkdir -p /tmp/#{binary["name"]}"
    dockerfile << "RUN tar -xJf /tmp/#{binary["name"]}.tar.xz -C /tmp/#{binary["name"]}"
    dockerfile << "RUN ls -1 /tmp/#{binary["name"]} | xargs -I {} rsync -a --remove-source-files /tmp/#{binary["name"]}/{}/ /usr/local"
  else
    raise "Unsupported binary: #{binary}"
  end
end

dockerfile << ""
dockerfile << "# Vim"

entrypoint = nil
pack_root = nil
config_root = nil

case manifest["vim"]["vim"]
when "neovim"
  versions = fetch_tags("neovim/neovim")
  releases = sort_by_version(versions.reject { |version| version == "nightly" })

  versions = [versions.find { |version| version == "nightly" }, *releases]

  version = resolve_version(versions, manifest["vim"]["version"], "neovim")

  dockerfile << "RUN curl -Lfo /tmp/nvim.tgz https://github.com/neovim/neovim/releases/download/v0.10.0/nvim-linux64.tar.gz"
  dockerfile << "RUN tar -xzf /tmp/nvim.tgz -C /usr/local"
  dockerfile << "RUN ln -s /usr/local/nvim-linux64/bin/nvim /usr/bin/nvim"

  pack_root = "/root/.config/nvim/pack/plugins/start"
  entrypoint = "/usr/bin/nvim"
  config_root = "/root/.config/nvim"
when "vim"
  vims = fetch_tags("vim/vim")
  versions = sort_by_version(vims)

  version = resolve_version(versions, manifest["vim"]["version"], "vim")

  assets =
    client.release(
      "https://api.github.com/repos/vim/vim-appimage/releases/tags/#{version}"
    )[
      "assets"
    ]
  appimage =
    assets.find do |asset|
      asset["name"].end_with?(".AppImage") && !asset["name"].include?("GVim")
    end
  raise "AppImage not found" if appimage.nil?

  dockerfile << "RUN curl -Lfo /tmp/vim.AppImage #{appimage["browser_download_url"]}"
  dockerfile << "RUN chmod +x /tmp/vim.AppImage"
  dockerfile << "RUN /tmp/vim.AppImage --appimage-extract"
  dockerfile << "RUN rsync /squashfs-root/usr/ /usr"

  pack_root = "/root/.vim/pack/plugins/start"
  entrypoint = "/usr/bin/vim"
  config_root = "/root/.vim"
else
  raise "Unsupported type: #{manifest["vim"]["vim"]}"
end

dockerfile << ""
dockerfile << "# Plugins"
if (plugins = manifest["plugins"])
  dockerfile << "RUN mkdir -p #{pack_root}"
  plugins.each do |plugin|
    plugin = { "repo" => plugin } if plugin.is_a?(String)
    name = plugin["name"] || plugin["repo"].split("/").last
    remote = "https://github.com/#{plugin["repo"]}"
    dockerfile << if plugin["ref"]
      "RUN #{
        [
          "mkdir -p #{pack_root}/#{name}",
          "cd #{pack_root}/#{name}",
          "git init",
          "git remote add origin #{remote}",
          "git fetch --depth 1 origin #{plugin["ref"]}",
          "git checkout FETCH_HEAD"
        ].join(" && \\\n    ")
      }"
    else
      "RUN git clone --depth 1 #{remote} #{pack_root}/#{name}"
    end

    if plugin["post_install"]
      dockerfile << "RUN   #{
        [
          "cd #{pack_root}/#{name}",
          "echo #{Base64.strict_encode64(plugin["post_install"]).strip} | base64 -d | bash"
        ].join(" && ")
      }"
    end
  end
end

if (files = manifest["configs"])
  dockerfile << ""
  dockerfile << "# Configs"
  dockerfile << "RUN mkdir -p #{config_root}"
  files.each do |file_name, content|
    dockerfile << "# - #{file_name}"
    path =
      if file_name == ".vimrc"
        "/root/.vimrc"
      else
        File.join(config_root, file_name)
      end
    dockerfile << "RUN echo #{Base64.strict_encode64(content).strip} | base64 -d > #{path}"
  end
end

dockerfile << ""
dockerfile << "ENV SHELL=/bin/bash"
dockerfile << %(ENTRYPOINT ["/bin/bash", "-ic", "#{entrypoint}"])

dockerfile_str = highlight_dockerfile(dockerfile.join("\n"))

if output == "-"
  puts dockerfile_str
else
  File.write(output, dockerfile.join("\n"))
  puts "Wrote Dockerfile to #{output}"
end

if run
  unless options[:yes]
    print "Run Dockerfile? [Y/n] "
    confirm = $stdin.getch
    puts confirm
    exit unless %W[y Y \r \n].include?(confirm)
  end
  tempdir = Dir.mktmpdir
  temp_dockerfile = File.join(tempdir, "Dockerfile")
  File.write(temp_dockerfile, dockerfile.join("\n"))
  nonce = SecureRandom.hex(4)
  begin
    system(
      "docker build -t vim-imagegen-#{nonce} .",
      exception: true,
      chdir: tempdir
    )
    system(
      "docker run -it --rm vim-imagegen-#{nonce}",
      exception: true,
      chdir: tempdir
    )
  ensure
    system("docker rmi vim-imagegen-#{nonce}", exception: true)
  end
end
